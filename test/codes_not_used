#################################################################################################
##### Try to update collision parameters of cans after simulation starts, but it does not work.

body_id_can = Vector{Int}(undef, 3)
body_id_can[1] = MJ.mj_name2id(model, MJ.mjOBJ_BODY, "can1")
body_id_can[2] = MJ.mj_name2id(model, MJ.mjOBJ_BODY, "can2")
body_id_can[3] = MJ.mj_name2id(model, MJ.mjOBJ_BODY, "can3")
# @assert body_id != -1 "not find object can1"

function mycontroller!(model, data)
    pos_can = Vector{Vector{<:Real}}(undef, 3)
    has_triggered_can = Vector{Bool}(undef, 3)
    pos_can[1] = data.xpos[body_id_can[1] + 1, :]  # [x,y,z] MuJoCo is based on C++
    pos_can[2] = data.xpos[body_id_can[2] + 1, :]
    pos_can[3] = data.xpos[body_id_can[3] + 1, :]
    has_triggered_can[1:3] .= false 
    for i in 1:3
        if !has_triggered_can[i] && pos_can[i][2] > 0.75
            model.geom_contype[body_id_can[i]] = 2
            model.geom_conaffinity[body_id_can[i]] = 0
            has_triggered_can[i] = true
        end
    end
    MJ.mj_forward(model, data)
end

MJ.init_visualiser()  # Load required dependencies into session
MJ.visualise!(model, data, controller=mycontroller!) # Run the visualiser

#################################################################################################

##### This code is part of a simulation for a robotic arm using torque control

nv = 9  # Number of joints in the robotic arm
nu = 8
MJ.mj_inverse(model, data)
qfrc0 = copy(data.qfrc_inverse[1:nv])
M_act = data.actuator_moment[:,1:nv]

R = Matrix{Float64}(LA.I, nu, nu) + (1e-6) * LA.I

link0 = MJ.body(model,"link0")
jac_com = MJ.mj_zeros(3, model.nv)
MJ.mj_jacSubtreeCom(model, data, jac_com, link0.id)
jac_com = jac_com[1:3, 1:nv]

link7 = MJ.body(model,"link7")
jac_foot = MJ.mj_zeros(3, model.nv)
MJ.mj_jacBodyCom(model, data, jac_foot, nothing, link7.id)
jac_foot = jac_foot[1:3, 1:nv]

jac_diff = jac_com .- jac_foot
Qbalance = jac_diff' * jac_diff

balance_dofs = [1, 2, 3, 4]  # Joints that need to balance
other_dofs = setdiff(1:nv, balance_dofs)
balance_joint_cost = 3          # Joints can move a bit and still balance
other_joint_cost   = 0.3        # Other joints can do whatever
Qjoint = Matrix{Float64}(LA.I, nv, nv)
Qjoint[balance_dofs, balance_dofs] *= balance_joint_cost
Qjoint[other_dofs, other_dofs] *= other_joint_cost
balance_cost = 1000
Qpos = balance_cost*Qbalance + Qjoint
Q = [Qpos zeros(nv,nv); zeros(nv, 2nv)]  + (1e-6) * LA.I

ϵ = 1e-6
centred = true
A = MJ.mj_zeros(2*model.nv, 2*model.nv)
B = MJ.mj_zeros(2*model.nv, model.nu)
MJ.mjd_transitionFD(model, data, ϵ, centred, A, B, nothing, nothing)
# A = DelimitedFiles.readdlm("A.txt", Float64)
# B = DelimitedFiles.readdlm("B.txt", Float64)

S = zeros(2nv, nu)
_, _, K, _ = MatrixEquations.ared(A,B,R,Q,S)
# dis_sys = ControlSystems.ss(A, B, LA.I(size(A,1)), 0)
# K = -ControlSystems.lqr(dis_sys, Q, R)  # 返回增益矩阵

Δq = zeros(nv)
MJ.mj_differentiatePos(model, Δq, 1, target_positions[:home], data.qpos[1:nv])
Δx = vcat(Δq, data.qvel[1:nv])
data.ctrl .= LA.pinv(M_act)' * qfrc0 .- K* Δx

#################################################################################################
#     current_pos = data.xpos[body_id[6] + 1, :]  # Joint 7 position
    #     pos_error = Vector{Vector{<:Real}}(undef, 3)
    #     pos_error[1] = pos_can[1] - current_pos
    Kp = 1
    Kd = 0.5

    nv = 9  # Number of joints in the robotic arm
    pos_can = Vector{Vector{<:Real}}(undef, 3)
    pos_can[1] = data.xpos[body_id[1] + 1, :]  # [x,y,z] MuJoCo is based on C++
    current_pos = data.xpos[body_id[6] + 1, :]  # Joint 7 position
    pos_error = Vector{Vector{<:Real}}(undef, 3)
    pos_error[1] = pos_can[1] - current_pos
    pick_trigger = false
    if data.time < 2.
        MJ.mj_inverse(model, data)
        qfrc0 = copy(data.qfrc_inverse[1:nv])
        M_act = data.actuator_moment[:,1:nv]
        data.ctrl .= LA.pinv(M_act)' * qfrc0
# - Kp * (model.jnt_pos[1:nv] - target_positions[:pick_pre1]) .+ 
    elseif data.time >= 3.0
        pick_trigger = true
    end


    # if !pick_pre_trigger && LA.norm(pos_error[1]) < 1.5
    #     pick_pre_trigger = true
    # end
    # if pick_pre_trigger && !pick_trigger
    #     data.ctrl .= target_positions[:pick_pre]
    # end
    # if !pick_trigger && LA.norm(pos_error[1]) < 0.4
    #     pick_trigger = true
    # end
    if pick_trigger
        quat_can = Vector{Vector{<:Real}}(undef, 3)
        quat_can[1] = data.xquat[body_id[1] + 1, :]  # [x,y,z,w]
        current_quat = data.xquat[body_id[6] + 1, :]  # Joint 7 orientation 
        quat_error = Vector{Vector{<:Real}}(undef, 3)
        quat_error[1] = compute_quat_error(quat_can[1], current_quat)
        rot_error = Vector{Vector{<:Real}}(undef, 3)
        rot_error[1] = quat_to_vel(quat_error[1])
        task_error = [pos_error[1]; rot_error[1]]

        J = MJ.mj_jacSite(model, data, body_id[6])
        # J = manual_jacobian(model, data, body_id[6])

        lambda = 0.1
        # lambda = 0.1 * LA.exp(-1/LA.svd(J).S[end])
        # if lambda < 0.01
        #     lambda = 0.01
        # end
        J_dls = J' * LA.inv(J * J' + lambda^2 * LA.I(6))
        
        torque_motor = MJ.mj_ActuatorMotor()
        data.ctrl .= Kp .* 0.1 .* J_dls * task_error .- Kd .* data.qvel[1:nv]

        println("task_error: ", task_error)
        
        # Δq = J_dls * (Kp * task_error - Kd * J * data.qvel[1:nv])
        
        # data.ctrl .= target_positions[:pick]
    end